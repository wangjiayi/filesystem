Here you will develop a Python modules fs which creates and manages a private file system. This will be a "parallel universe" in which the usual functions are available, e.g. fs.chdir() rather than os.chdir(). Here is the overview:

An fs system will be created within a native file f specified by the file system administrator. It is presumed to exist before this call.It would be nice to have this as a multiuser, multiprocess sytem, but that would become toocomplicated. So, it will be single-user, one process running at a time.

In creating the file system, the user must first call fs.init(fsname). The argument is the name of the native file in which we will do our storage. Note: The native file's purpose is simply to create space for your file system. Its contents will be overwritten.File name specification in the calls described below is done either using relative or absolute path. The root directory is /, and that character is also the separator in path names. The expressions . and .. have the same meaning as in Unix-family systems.

Error checking is required in the cases specified below. Handle this via Python's raise and Exception() features.The system will have a function fs.create(filename,nbytes). The nbytes argument specifies the number of bytes needed for the file. When this function is called, fs will attempt to allocate space for the file. Typically the space will consist of multiple chunks within the native file f; of course fs must record this information. The function will raise an exception upon failure to allocate space. The bytes will be initialized to NULLs, i.e. all bits 0.

There will be a function fs.mkdir(dirname).The system will have a function fs.open(filename,mode), where mode is either 'r' or 'w'. The return value will be a file descriptor as with the Python open(), except that it will now be a file descriptor for fs. The code will raise an exception if (a) the file system is currently suspended or (b) there is no such file.There will also be a function fs.close(fd), with a single argument, the file descriptor.

The function fs.length(fd) will return the current number of bytes actually used in the file, initially 0. The argument fd is the file descriptor. For example, say the file is created with size 100 bytes, and then 3 bytes are written. These will be in bytes 0-2 of the file, and the length will be 3.The function fs.pos(fd) will return the current read/write position in the file. This is initially set to 0 by fs.open(), i.e. the beginning of the file.

The function fs.seek(fd,pos) will set the current read/write position to pos. An exception is raised if (a) the argument is negative or (b) greater than the file size or (c) would make the file bytes non-contiguous.There will be these I/O functions:fs.read(fd,nbytes); returns a string; raises an exception if the read would extend beyond the current length of the file. fs.write(fd,writebuf), where writebuf is a string fs.readlines(fd); reads the entire file, returning a list of strings; treats any 0xa byte it encounters as end of a line; does NOT change the pos value

There will be functions fs.delfile(filename) and fs.deldir(dirname) to delete files and directories. Raise an exception if the file/directory doesn't exist or (b) the file is open or (c) the calling process is currently within the specified directory.Have functions fs.isdir(dirname), fs.chdir(dirname) and fs.listdir(dirname), to work like their Python os counterparts.

It is presumed that the machine on which the file system is stored will not always be up, or the user may not always be logged on. So, the user can temporarily suspend the system, by calling fs.suspend(), and later resume service via fs.resume(). Suspension will not be allowed if any files are open for writing.Upon suspension, all data structures etc. are saved to a native file whose name is the concatenation of the name of f and '.fssave'. This name will be the argument to fs.resume(). The saving/resuming of the system is done via the Python pickle module.